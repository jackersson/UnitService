// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: datatypes/key.proto

#ifndef PROTOBUF_datatypes_2fkey_2eproto__INCLUDED
#define PROTOBUF_datatypes_2fkey_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace DataTypes {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_datatypes_2fkey_2eproto();
void protobuf_AssignDesc_datatypes_2fkey_2eproto();
void protobuf_ShutdownFile_datatypes_2fkey_2eproto();

class Key;

// ===================================================================

class Key : public ::google::protobuf::Message {
 public:
  Key();
  virtual ~Key();

  Key(const Key& from);

  inline Key& operator=(const Key& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Key& default_instance();

  enum IdTypeCase {
    kNumber = 1,
    kIdentifier = 2,
    kGuid = 3,
    ID_TYPE_NOT_SET = 0,
  };

  void Swap(Key* other);

  // implements Message ----------------------------------------------

  inline Key* New() const { return New(NULL); }

  Key* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Key& from);
  void MergeFrom(const Key& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Key* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 number = 1;
  private:
  bool has_number() const;
  public:
  void clear_number();
  static const int kNumberFieldNumber = 1;
  ::google::protobuf::int64 number() const;
  void set_number(::google::protobuf::int64 value);

  // optional string identifier = 2;
  private:
  bool has_identifier() const;
  public:
  void clear_identifier();
  static const int kIdentifierFieldNumber = 2;
  const ::std::string& identifier() const;
  void set_identifier(const ::std::string& value);
  void set_identifier(const char* value);
  void set_identifier(const char* value, size_t size);
  ::std::string* mutable_identifier();
  ::std::string* release_identifier();
  void set_allocated_identifier(::std::string* identifier);

  // optional bytes guid = 3;
  private:
  bool has_guid() const;
  public:
  void clear_guid();
  static const int kGuidFieldNumber = 3;
  const ::std::string& guid() const;
  void set_guid(const ::std::string& value);
  void set_guid(const char* value);
  void set_guid(const void* value, size_t size);
  ::std::string* mutable_guid();
  ::std::string* release_guid();
  void set_allocated_guid(::std::string* guid);

  IdTypeCase id_type_case() const;
  // @@protoc_insertion_point(class_scope:DataTypes.Key)
 private:
  inline void set_has_number();
  inline void set_has_identifier();
  inline void set_has_guid();

  inline bool has_id_type() const;
  void clear_id_type();
  inline void clear_has_id_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union IdTypeUnion {
    IdTypeUnion() {}
    ::google::protobuf::int64 number_;
    ::google::protobuf::internal::ArenaStringPtr identifier_;
    ::google::protobuf::internal::ArenaStringPtr guid_;
  } id_type_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_datatypes_2fkey_2eproto();
  friend void protobuf_AssignDesc_datatypes_2fkey_2eproto();
  friend void protobuf_ShutdownFile_datatypes_2fkey_2eproto();

  void InitAsDefaultInstance();
  static Key* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Key

// optional int64 number = 1;
inline bool Key::has_number() const {
  return id_type_case() == kNumber;
}
inline void Key::set_has_number() {
  _oneof_case_[0] = kNumber;
}
inline void Key::clear_number() {
  if (has_number()) {
    id_type_.number_ = GOOGLE_LONGLONG(0);
    clear_has_id_type();
  }
}
inline ::google::protobuf::int64 Key::number() const {
  // @@protoc_insertion_point(field_get:DataTypes.Key.number)
  if (has_number()) {
    return id_type_.number_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void Key::set_number(::google::protobuf::int64 value) {
  if (!has_number()) {
    clear_id_type();
    set_has_number();
  }
  id_type_.number_ = value;
  // @@protoc_insertion_point(field_set:DataTypes.Key.number)
}

// optional string identifier = 2;
inline bool Key::has_identifier() const {
  return id_type_case() == kIdentifier;
}
inline void Key::set_has_identifier() {
  _oneof_case_[0] = kIdentifier;
}
inline void Key::clear_identifier() {
  if (has_identifier()) {
    id_type_.identifier_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_id_type();
  }
}
inline const ::std::string& Key::identifier() const {
  // @@protoc_insertion_point(field_get:DataTypes.Key.identifier)
  if (has_identifier()) {
    return id_type_.identifier_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Key::set_identifier(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:DataTypes.Key.identifier)
  if (!has_identifier()) {
    clear_id_type();
    set_has_identifier();
    id_type_.identifier_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_type_.identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DataTypes.Key.identifier)
}
inline void Key::set_identifier(const char* value) {
  if (!has_identifier()) {
    clear_id_type();
    set_has_identifier();
    id_type_.identifier_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_type_.identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DataTypes.Key.identifier)
}
inline void Key::set_identifier(const char* value, size_t size) {
  if (!has_identifier()) {
    clear_id_type();
    set_has_identifier();
    id_type_.identifier_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_type_.identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DataTypes.Key.identifier)
}
inline ::std::string* Key::mutable_identifier() {
  if (!has_identifier()) {
    clear_id_type();
    set_has_identifier();
    id_type_.identifier_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:DataTypes.Key.identifier)
  return id_type_.identifier_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Key::release_identifier() {
  // @@protoc_insertion_point(field_release:DataTypes.Key.identifier)
  if (has_identifier()) {
    clear_has_id_type();
    return id_type_.identifier_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Key::set_allocated_identifier(::std::string* identifier) {
  if (!has_identifier()) {
    id_type_.identifier_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_id_type();
  if (identifier != NULL) {
    set_has_identifier();
    id_type_.identifier_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        identifier);
  }
  // @@protoc_insertion_point(field_set_allocated:DataTypes.Key.identifier)
}

// optional bytes guid = 3;
inline bool Key::has_guid() const {
  return id_type_case() == kGuid;
}
inline void Key::set_has_guid() {
  _oneof_case_[0] = kGuid;
}
inline void Key::clear_guid() {
  if (has_guid()) {
    id_type_.guid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_id_type();
  }
}
inline const ::std::string& Key::guid() const {
  // @@protoc_insertion_point(field_get:DataTypes.Key.guid)
  if (has_guid()) {
    return id_type_.guid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Key::set_guid(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:DataTypes.Key.guid)
  if (!has_guid()) {
    clear_id_type();
    set_has_guid();
    id_type_.guid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_type_.guid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DataTypes.Key.guid)
}
inline void Key::set_guid(const char* value) {
  if (!has_guid()) {
    clear_id_type();
    set_has_guid();
    id_type_.guid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_type_.guid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DataTypes.Key.guid)
}
inline void Key::set_guid(const void* value, size_t size) {
  if (!has_guid()) {
    clear_id_type();
    set_has_guid();
    id_type_.guid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_type_.guid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DataTypes.Key.guid)
}
inline ::std::string* Key::mutable_guid() {
  if (!has_guid()) {
    clear_id_type();
    set_has_guid();
    id_type_.guid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:DataTypes.Key.guid)
  return id_type_.guid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Key::release_guid() {
  // @@protoc_insertion_point(field_release:DataTypes.Key.guid)
  if (has_guid()) {
    clear_has_id_type();
    return id_type_.guid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Key::set_allocated_guid(::std::string* guid) {
  if (!has_guid()) {
    id_type_.guid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_id_type();
  if (guid != NULL) {
    set_has_guid();
    id_type_.guid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        guid);
  }
  // @@protoc_insertion_point(field_set_allocated:DataTypes.Key.guid)
}

inline bool Key::has_id_type() const {
  return id_type_case() != ID_TYPE_NOT_SET;
}
inline void Key::clear_has_id_type() {
  _oneof_case_[0] = ID_TYPE_NOT_SET;
}
inline Key::IdTypeCase Key::id_type_case() const {
  return Key::IdTypeCase(_oneof_case_[0]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace DataTypes

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_datatypes_2fkey_2eproto__INCLUDED
