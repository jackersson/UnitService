// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: datatypes/devices.proto

#ifndef PROTOBUF_datatypes_2fdevices_2eproto__INCLUDED
#define PROTOBUF_datatypes_2fdevices_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "datatypes/key.pb.h"
// @@protoc_insertion_point(includes)

namespace DataTypes {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_datatypes_2fdevices_2eproto();
void protobuf_AssignDesc_datatypes_2fdevices_2eproto();
void protobuf_ShutdownFile_datatypes_2fdevices_2eproto();

class AccessDevice;
class AccessDeviceStateMsg;
class CardMsg;
class CheckMsg;
class Device;
class DeviceStateMessage;
class DeviceUpdate;
class Devices;
class GenericDeviceStateMsg;

enum DeviceType {
  None_Type = 0,
  CardReader = 1,
  Capture = 2,
  DeviceType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DeviceType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DeviceType_IsValid(int value);
const DeviceType DeviceType_MIN = None_Type;
const DeviceType DeviceType_MAX = Capture;
const int DeviceType_ARRAYSIZE = DeviceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DeviceType_descriptor();
inline const ::std::string& DeviceType_Name(DeviceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DeviceType_descriptor(), value);
}
inline bool DeviceType_Parse(
    const ::std::string& name, DeviceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DeviceType>(
    DeviceType_descriptor(), name, value);
}
enum DeviceState {
  None_State = 0,
  Active = 1,
  StoppedByUser = 2,
  Paused = 3,
  Stopped = 4,
  Error = 5,
  DeviceState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DeviceState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DeviceState_IsValid(int value);
const DeviceState DeviceState_MIN = None_State;
const DeviceState DeviceState_MAX = Error;
const int DeviceState_ARRAYSIZE = DeviceState_MAX + 1;

const ::google::protobuf::EnumDescriptor* DeviceState_descriptor();
inline const ::std::string& DeviceState_Name(DeviceState value) {
  return ::google::protobuf::internal::NameOfEnum(
    DeviceState_descriptor(), value);
}
inline bool DeviceState_Parse(
    const ::std::string& name, DeviceState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DeviceState>(
    DeviceState_descriptor(), name, value);
}
// ===================================================================

class AccessDevice : public ::google::protobuf::Message {
 public:
  AccessDevice();
  virtual ~AccessDevice();

  AccessDevice(const AccessDevice& from);

  inline AccessDevice& operator=(const AccessDevice& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccessDevice& default_instance();

  void Swap(AccessDevice* other);

  // implements Message ----------------------------------------------

  inline AccessDevice* New() const { return New(NULL); }

  AccessDevice* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccessDevice& from);
  void MergeFrom(const AccessDevice& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AccessDevice* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional fixed64 serial_number = 2;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 2;
  ::google::protobuf::uint64 serial_number() const;
  void set_serial_number(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:DataTypes.AccessDevice)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint64 serial_number_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_datatypes_2fdevices_2eproto();
  friend void protobuf_AssignDesc_datatypes_2fdevices_2eproto();
  friend void protobuf_ShutdownFile_datatypes_2fdevices_2eproto();

  void InitAsDefaultInstance();
  static AccessDevice* default_instance_;
};
// -------------------------------------------------------------------

class DeviceUpdate : public ::google::protobuf::Message {
 public:
  DeviceUpdate();
  virtual ~DeviceUpdate();

  DeviceUpdate(const DeviceUpdate& from);

  inline DeviceUpdate& operator=(const DeviceUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceUpdate& default_instance();

  enum UpdateCase {
    kItems = 1,
    kDeviceStateMsg = 2,
    UPDATE_NOT_SET = 0,
  };

  void Swap(DeviceUpdate* other);

  // implements Message ----------------------------------------------

  inline DeviceUpdate* New() const { return New(NULL); }

  DeviceUpdate* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceUpdate& from);
  void MergeFrom(const DeviceUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .DataTypes.Devices items = 1;
  bool has_items() const;
  void clear_items();
  static const int kItemsFieldNumber = 1;
  const ::DataTypes::Devices& items() const;
  ::DataTypes::Devices* mutable_items();
  ::DataTypes::Devices* release_items();
  void set_allocated_items(::DataTypes::Devices* items);

  // optional .DataTypes.DeviceStateMessage device_state_msg = 2;
  bool has_device_state_msg() const;
  void clear_device_state_msg();
  static const int kDeviceStateMsgFieldNumber = 2;
  const ::DataTypes::DeviceStateMessage& device_state_msg() const;
  ::DataTypes::DeviceStateMessage* mutable_device_state_msg();
  ::DataTypes::DeviceStateMessage* release_device_state_msg();
  void set_allocated_device_state_msg(::DataTypes::DeviceStateMessage* device_state_msg);

  UpdateCase update_case() const;
  // @@protoc_insertion_point(class_scope:DataTypes.DeviceUpdate)
 private:
  inline void set_has_items();
  inline void set_has_device_state_msg();

  inline bool has_update() const;
  void clear_update();
  inline void clear_has_update();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union UpdateUnion {
    UpdateUnion() {}
    ::DataTypes::Devices* items_;
    ::DataTypes::DeviceStateMessage* device_state_msg_;
  } update_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_datatypes_2fdevices_2eproto();
  friend void protobuf_AssignDesc_datatypes_2fdevices_2eproto();
  friend void protobuf_ShutdownFile_datatypes_2fdevices_2eproto();

  void InitAsDefaultInstance();
  static DeviceUpdate* default_instance_;
};
// -------------------------------------------------------------------

class Devices : public ::google::protobuf::Message {
 public:
  Devices();
  virtual ~Devices();

  Devices(const Devices& from);

  inline Devices& operator=(const Devices& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Devices& default_instance();

  void Swap(Devices* other);

  // implements Message ----------------------------------------------

  inline Devices* New() const { return New(NULL); }

  Devices* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Devices& from);
  void MergeFrom(const Devices& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Devices* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .DataTypes.Key location_id = 1;
  bool has_location_id() const;
  void clear_location_id();
  static const int kLocationIdFieldNumber = 1;
  const ::DataTypes::Key& location_id() const;
  ::DataTypes::Key* mutable_location_id();
  ::DataTypes::Key* release_location_id();
  void set_allocated_location_id(::DataTypes::Key* location_id);

  // repeated .DataTypes.Device devices = 2;
  int devices_size() const;
  void clear_devices();
  static const int kDevicesFieldNumber = 2;
  const ::DataTypes::Device& devices(int index) const;
  ::DataTypes::Device* mutable_devices(int index);
  ::DataTypes::Device* add_devices();
  ::google::protobuf::RepeatedPtrField< ::DataTypes::Device >*
      mutable_devices();
  const ::google::protobuf::RepeatedPtrField< ::DataTypes::Device >&
      devices() const;

  // @@protoc_insertion_point(class_scope:DataTypes.Devices)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::DataTypes::Key* location_id_;
  ::google::protobuf::RepeatedPtrField< ::DataTypes::Device > devices_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_datatypes_2fdevices_2eproto();
  friend void protobuf_AssignDesc_datatypes_2fdevices_2eproto();
  friend void protobuf_ShutdownFile_datatypes_2fdevices_2eproto();

  void InitAsDefaultInstance();
  static Devices* default_instance_;
};
// -------------------------------------------------------------------

class Device : public ::google::protobuf::Message {
 public:
  Device();
  virtual ~Device();

  Device(const Device& from);

  inline Device& operator=(const Device& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Device& default_instance();

  void Swap(Device* other);

  // implements Message ----------------------------------------------

  inline Device* New() const { return New(NULL); }

  Device* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Device& from);
  void MergeFrom(const Device& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Device* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .DataTypes.DeviceType device_type = 1;
  void clear_device_type();
  static const int kDeviceTypeFieldNumber = 1;
  ::DataTypes::DeviceType device_type() const;
  void set_device_type(::DataTypes::DeviceType value);

  // optional string device_name = 2;
  void clear_device_name();
  static const int kDeviceNameFieldNumber = 2;
  const ::std::string& device_name() const;
  void set_device_name(const ::std::string& value);
  void set_device_name(const char* value);
  void set_device_name(const char* value, size_t size);
  ::std::string* mutable_device_name();
  ::std::string* release_device_name();
  void set_allocated_device_name(::std::string* device_name);

  // @@protoc_insertion_point(class_scope:DataTypes.Device)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr device_name_;
  int device_type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_datatypes_2fdevices_2eproto();
  friend void protobuf_AssignDesc_datatypes_2fdevices_2eproto();
  friend void protobuf_ShutdownFile_datatypes_2fdevices_2eproto();

  void InitAsDefaultInstance();
  static Device* default_instance_;
};
// -------------------------------------------------------------------

class DeviceStateMessage : public ::google::protobuf::Message {
 public:
  DeviceStateMessage();
  virtual ~DeviceStateMessage();

  DeviceStateMessage(const DeviceStateMessage& from);

  inline DeviceStateMessage& operator=(const DeviceStateMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceStateMessage& default_instance();

  enum MsgCase {
    kGenericDeviceStateMsg = 1,
    kAccessDeviceStateMsg = 2,
    MSG_NOT_SET = 0,
  };

  void Swap(DeviceStateMessage* other);

  // implements Message ----------------------------------------------

  inline DeviceStateMessage* New() const { return New(NULL); }

  DeviceStateMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceStateMessage& from);
  void MergeFrom(const DeviceStateMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceStateMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .DataTypes.GenericDeviceStateMsg generic_device_state_msg = 1;
  bool has_generic_device_state_msg() const;
  void clear_generic_device_state_msg();
  static const int kGenericDeviceStateMsgFieldNumber = 1;
  const ::DataTypes::GenericDeviceStateMsg& generic_device_state_msg() const;
  ::DataTypes::GenericDeviceStateMsg* mutable_generic_device_state_msg();
  ::DataTypes::GenericDeviceStateMsg* release_generic_device_state_msg();
  void set_allocated_generic_device_state_msg(::DataTypes::GenericDeviceStateMsg* generic_device_state_msg);

  // optional .DataTypes.AccessDeviceStateMsg access_device_state_msg = 2;
  bool has_access_device_state_msg() const;
  void clear_access_device_state_msg();
  static const int kAccessDeviceStateMsgFieldNumber = 2;
  const ::DataTypes::AccessDeviceStateMsg& access_device_state_msg() const;
  ::DataTypes::AccessDeviceStateMsg* mutable_access_device_state_msg();
  ::DataTypes::AccessDeviceStateMsg* release_access_device_state_msg();
  void set_allocated_access_device_state_msg(::DataTypes::AccessDeviceStateMsg* access_device_state_msg);

  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:DataTypes.DeviceStateMessage)
 private:
  inline void set_has_generic_device_state_msg();
  inline void set_has_access_device_state_msg();

  inline bool has_msg() const;
  void clear_msg();
  inline void clear_has_msg();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union MsgUnion {
    MsgUnion() {}
    ::DataTypes::GenericDeviceStateMsg* generic_device_state_msg_;
    ::DataTypes::AccessDeviceStateMsg* access_device_state_msg_;
  } msg_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_datatypes_2fdevices_2eproto();
  friend void protobuf_AssignDesc_datatypes_2fdevices_2eproto();
  friend void protobuf_ShutdownFile_datatypes_2fdevices_2eproto();

  void InitAsDefaultInstance();
  static DeviceStateMessage* default_instance_;
};
// -------------------------------------------------------------------

class GenericDeviceStateMsg : public ::google::protobuf::Message {
 public:
  GenericDeviceStateMsg();
  virtual ~GenericDeviceStateMsg();

  GenericDeviceStateMsg(const GenericDeviceStateMsg& from);

  inline GenericDeviceStateMsg& operator=(const GenericDeviceStateMsg& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GenericDeviceStateMsg& default_instance();

  void Swap(GenericDeviceStateMsg* other);

  // implements Message ----------------------------------------------

  inline GenericDeviceStateMsg* New() const { return New(NULL); }

  GenericDeviceStateMsg* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GenericDeviceStateMsg& from);
  void MergeFrom(const GenericDeviceStateMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GenericDeviceStateMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .DataTypes.Key location_id = 1;
  bool has_location_id() const;
  void clear_location_id();
  static const int kLocationIdFieldNumber = 1;
  const ::DataTypes::Key& location_id() const;
  ::DataTypes::Key* mutable_location_id();
  ::DataTypes::Key* release_location_id();
  void set_allocated_location_id(::DataTypes::Key* location_id);

  // optional .DataTypes.DeviceType type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::DataTypes::DeviceType type() const;
  void set_type(::DataTypes::DeviceType value);

  // optional .DataTypes.DeviceState state = 3;
  void clear_state();
  static const int kStateFieldNumber = 3;
  ::DataTypes::DeviceState state() const;
  void set_state(::DataTypes::DeviceState value);

  // optional string message = 4;
  void clear_message();
  static const int kMessageFieldNumber = 4;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:DataTypes.GenericDeviceStateMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::DataTypes::Key* location_id_;
  int type_;
  int state_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_datatypes_2fdevices_2eproto();
  friend void protobuf_AssignDesc_datatypes_2fdevices_2eproto();
  friend void protobuf_ShutdownFile_datatypes_2fdevices_2eproto();

  void InitAsDefaultInstance();
  static GenericDeviceStateMsg* default_instance_;
};
// -------------------------------------------------------------------

class AccessDeviceStateMsg : public ::google::protobuf::Message {
 public:
  AccessDeviceStateMsg();
  virtual ~AccessDeviceStateMsg();

  AccessDeviceStateMsg(const AccessDeviceStateMsg& from);

  inline AccessDeviceStateMsg& operator=(const AccessDeviceStateMsg& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccessDeviceStateMsg& default_instance();

  void Swap(AccessDeviceStateMsg* other);

  // implements Message ----------------------------------------------

  inline AccessDeviceStateMsg* New() const { return New(NULL); }

  AccessDeviceStateMsg* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccessDeviceStateMsg& from);
  void MergeFrom(const AccessDeviceStateMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AccessDeviceStateMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .DataTypes.Key location_id = 1;
  bool has_location_id() const;
  void clear_location_id();
  static const int kLocationIdFieldNumber = 1;
  const ::DataTypes::Key& location_id() const;
  ::DataTypes::Key* mutable_location_id();
  ::DataTypes::Key* release_location_id();
  void set_allocated_location_id(::DataTypes::Key* location_id);

  // optional bool opened = 2;
  void clear_opened();
  static const int kOpenedFieldNumber = 2;
  bool opened() const;
  void set_opened(bool value);

  // @@protoc_insertion_point(class_scope:DataTypes.AccessDeviceStateMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::DataTypes::Key* location_id_;
  bool opened_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_datatypes_2fdevices_2eproto();
  friend void protobuf_AssignDesc_datatypes_2fdevices_2eproto();
  friend void protobuf_ShutdownFile_datatypes_2fdevices_2eproto();

  void InitAsDefaultInstance();
  static AccessDeviceStateMsg* default_instance_;
};
// -------------------------------------------------------------------

class CardMsg : public ::google::protobuf::Message {
 public:
  CardMsg();
  virtual ~CardMsg();

  CardMsg(const CardMsg& from);

  inline CardMsg& operator=(const CardMsg& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CardMsg& default_instance();

  void Swap(CardMsg* other);

  // implements Message ----------------------------------------------

  inline CardMsg* New() const { return New(NULL); }

  CardMsg* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CardMsg& from);
  void MergeFrom(const CardMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CardMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string card_num = 1;
  void clear_card_num();
  static const int kCardNumFieldNumber = 1;
  const ::std::string& card_num() const;
  void set_card_num(const ::std::string& value);
  void set_card_num(const char* value);
  void set_card_num(const char* value, size_t size);
  ::std::string* mutable_card_num();
  ::std::string* release_card_num();
  void set_allocated_card_num(::std::string* card_num);

  // @@protoc_insertion_point(class_scope:DataTypes.CardMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr card_num_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_datatypes_2fdevices_2eproto();
  friend void protobuf_AssignDesc_datatypes_2fdevices_2eproto();
  friend void protobuf_ShutdownFile_datatypes_2fdevices_2eproto();

  void InitAsDefaultInstance();
  static CardMsg* default_instance_;
};
// -------------------------------------------------------------------

class CheckMsg : public ::google::protobuf::Message {
 public:
  CheckMsg();
  virtual ~CheckMsg();

  CheckMsg(const CheckMsg& from);

  inline CheckMsg& operator=(const CheckMsg& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckMsg& default_instance();

  void Swap(CheckMsg* other);

  // implements Message ----------------------------------------------

  inline CheckMsg* New() const { return New(NULL); }

  CheckMsg* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckMsg& from);
  void MergeFrom(const CheckMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CheckMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool ok = 1;
  void clear_ok();
  static const int kOkFieldNumber = 1;
  bool ok() const;
  void set_ok(bool value);

  // optional string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:DataTypes.CheckMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  bool ok_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_datatypes_2fdevices_2eproto();
  friend void protobuf_AssignDesc_datatypes_2fdevices_2eproto();
  friend void protobuf_ShutdownFile_datatypes_2fdevices_2eproto();

  void InitAsDefaultInstance();
  static CheckMsg* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// AccessDevice

// optional string name = 1;
inline void AccessDevice::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccessDevice::name() const {
  // @@protoc_insertion_point(field_get:DataTypes.AccessDevice.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccessDevice::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DataTypes.AccessDevice.name)
}
inline void AccessDevice::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DataTypes.AccessDevice.name)
}
inline void AccessDevice::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DataTypes.AccessDevice.name)
}
inline ::std::string* AccessDevice::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:DataTypes.AccessDevice.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccessDevice::release_name() {
  // @@protoc_insertion_point(field_release:DataTypes.AccessDevice.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccessDevice::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:DataTypes.AccessDevice.name)
}

// optional fixed64 serial_number = 2;
inline void AccessDevice::clear_serial_number() {
  serial_number_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AccessDevice::serial_number() const {
  // @@protoc_insertion_point(field_get:DataTypes.AccessDevice.serial_number)
  return serial_number_;
}
inline void AccessDevice::set_serial_number(::google::protobuf::uint64 value) {
  
  serial_number_ = value;
  // @@protoc_insertion_point(field_set:DataTypes.AccessDevice.serial_number)
}

// -------------------------------------------------------------------

// DeviceUpdate

// optional .DataTypes.Devices items = 1;
inline bool DeviceUpdate::has_items() const {
  return update_case() == kItems;
}
inline void DeviceUpdate::set_has_items() {
  _oneof_case_[0] = kItems;
}
inline void DeviceUpdate::clear_items() {
  if (has_items()) {
    delete update_.items_;
    clear_has_update();
  }
}
inline  const ::DataTypes::Devices& DeviceUpdate::items() const {
  // @@protoc_insertion_point(field_get:DataTypes.DeviceUpdate.items)
  return has_items()
      ? *update_.items_
      : ::DataTypes::Devices::default_instance();
}
inline ::DataTypes::Devices* DeviceUpdate::mutable_items() {
  if (!has_items()) {
    clear_update();
    set_has_items();
    update_.items_ = new ::DataTypes::Devices;
  }
  // @@protoc_insertion_point(field_mutable:DataTypes.DeviceUpdate.items)
  return update_.items_;
}
inline ::DataTypes::Devices* DeviceUpdate::release_items() {
  // @@protoc_insertion_point(field_release:DataTypes.DeviceUpdate.items)
  if (has_items()) {
    clear_has_update();
    ::DataTypes::Devices* temp = update_.items_;
    update_.items_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void DeviceUpdate::set_allocated_items(::DataTypes::Devices* items) {
  clear_update();
  if (items) {
    set_has_items();
    update_.items_ = items;
  }
  // @@protoc_insertion_point(field_set_allocated:DataTypes.DeviceUpdate.items)
}

// optional .DataTypes.DeviceStateMessage device_state_msg = 2;
inline bool DeviceUpdate::has_device_state_msg() const {
  return update_case() == kDeviceStateMsg;
}
inline void DeviceUpdate::set_has_device_state_msg() {
  _oneof_case_[0] = kDeviceStateMsg;
}
inline void DeviceUpdate::clear_device_state_msg() {
  if (has_device_state_msg()) {
    delete update_.device_state_msg_;
    clear_has_update();
  }
}
inline  const ::DataTypes::DeviceStateMessage& DeviceUpdate::device_state_msg() const {
  // @@protoc_insertion_point(field_get:DataTypes.DeviceUpdate.device_state_msg)
  return has_device_state_msg()
      ? *update_.device_state_msg_
      : ::DataTypes::DeviceStateMessage::default_instance();
}
inline ::DataTypes::DeviceStateMessage* DeviceUpdate::mutable_device_state_msg() {
  if (!has_device_state_msg()) {
    clear_update();
    set_has_device_state_msg();
    update_.device_state_msg_ = new ::DataTypes::DeviceStateMessage;
  }
  // @@protoc_insertion_point(field_mutable:DataTypes.DeviceUpdate.device_state_msg)
  return update_.device_state_msg_;
}
inline ::DataTypes::DeviceStateMessage* DeviceUpdate::release_device_state_msg() {
  // @@protoc_insertion_point(field_release:DataTypes.DeviceUpdate.device_state_msg)
  if (has_device_state_msg()) {
    clear_has_update();
    ::DataTypes::DeviceStateMessage* temp = update_.device_state_msg_;
    update_.device_state_msg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void DeviceUpdate::set_allocated_device_state_msg(::DataTypes::DeviceStateMessage* device_state_msg) {
  clear_update();
  if (device_state_msg) {
    set_has_device_state_msg();
    update_.device_state_msg_ = device_state_msg;
  }
  // @@protoc_insertion_point(field_set_allocated:DataTypes.DeviceUpdate.device_state_msg)
}

inline bool DeviceUpdate::has_update() const {
  return update_case() != UPDATE_NOT_SET;
}
inline void DeviceUpdate::clear_has_update() {
  _oneof_case_[0] = UPDATE_NOT_SET;
}
inline DeviceUpdate::UpdateCase DeviceUpdate::update_case() const {
  return DeviceUpdate::UpdateCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Devices

// optional .DataTypes.Key location_id = 1;
inline bool Devices::has_location_id() const {
  return !_is_default_instance_ && location_id_ != NULL;
}
inline void Devices::clear_location_id() {
  if (GetArenaNoVirtual() == NULL && location_id_ != NULL) delete location_id_;
  location_id_ = NULL;
}
inline const ::DataTypes::Key& Devices::location_id() const {
  // @@protoc_insertion_point(field_get:DataTypes.Devices.location_id)
  return location_id_ != NULL ? *location_id_ : *default_instance_->location_id_;
}
inline ::DataTypes::Key* Devices::mutable_location_id() {
  
  if (location_id_ == NULL) {
    location_id_ = new ::DataTypes::Key;
  }
  // @@protoc_insertion_point(field_mutable:DataTypes.Devices.location_id)
  return location_id_;
}
inline ::DataTypes::Key* Devices::release_location_id() {
  // @@protoc_insertion_point(field_release:DataTypes.Devices.location_id)
  
  ::DataTypes::Key* temp = location_id_;
  location_id_ = NULL;
  return temp;
}
inline void Devices::set_allocated_location_id(::DataTypes::Key* location_id) {
  delete location_id_;
  location_id_ = location_id;
  if (location_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:DataTypes.Devices.location_id)
}

// repeated .DataTypes.Device devices = 2;
inline int Devices::devices_size() const {
  return devices_.size();
}
inline void Devices::clear_devices() {
  devices_.Clear();
}
inline const ::DataTypes::Device& Devices::devices(int index) const {
  // @@protoc_insertion_point(field_get:DataTypes.Devices.devices)
  return devices_.Get(index);
}
inline ::DataTypes::Device* Devices::mutable_devices(int index) {
  // @@protoc_insertion_point(field_mutable:DataTypes.Devices.devices)
  return devices_.Mutable(index);
}
inline ::DataTypes::Device* Devices::add_devices() {
  // @@protoc_insertion_point(field_add:DataTypes.Devices.devices)
  return devices_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::DataTypes::Device >*
Devices::mutable_devices() {
  // @@protoc_insertion_point(field_mutable_list:DataTypes.Devices.devices)
  return &devices_;
}
inline const ::google::protobuf::RepeatedPtrField< ::DataTypes::Device >&
Devices::devices() const {
  // @@protoc_insertion_point(field_list:DataTypes.Devices.devices)
  return devices_;
}

// -------------------------------------------------------------------

// Device

// optional .DataTypes.DeviceType device_type = 1;
inline void Device::clear_device_type() {
  device_type_ = 0;
}
inline ::DataTypes::DeviceType Device::device_type() const {
  // @@protoc_insertion_point(field_get:DataTypes.Device.device_type)
  return static_cast< ::DataTypes::DeviceType >(device_type_);
}
inline void Device::set_device_type(::DataTypes::DeviceType value) {
  
  device_type_ = value;
  // @@protoc_insertion_point(field_set:DataTypes.Device.device_type)
}

// optional string device_name = 2;
inline void Device::clear_device_name() {
  device_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Device::device_name() const {
  // @@protoc_insertion_point(field_get:DataTypes.Device.device_name)
  return device_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Device::set_device_name(const ::std::string& value) {
  
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DataTypes.Device.device_name)
}
inline void Device::set_device_name(const char* value) {
  
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DataTypes.Device.device_name)
}
inline void Device::set_device_name(const char* value, size_t size) {
  
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DataTypes.Device.device_name)
}
inline ::std::string* Device::mutable_device_name() {
  
  // @@protoc_insertion_point(field_mutable:DataTypes.Device.device_name)
  return device_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Device::release_device_name() {
  // @@protoc_insertion_point(field_release:DataTypes.Device.device_name)
  
  return device_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Device::set_allocated_device_name(::std::string* device_name) {
  if (device_name != NULL) {
    
  } else {
    
  }
  device_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_name);
  // @@protoc_insertion_point(field_set_allocated:DataTypes.Device.device_name)
}

// -------------------------------------------------------------------

// DeviceStateMessage

// optional .DataTypes.GenericDeviceStateMsg generic_device_state_msg = 1;
inline bool DeviceStateMessage::has_generic_device_state_msg() const {
  return msg_case() == kGenericDeviceStateMsg;
}
inline void DeviceStateMessage::set_has_generic_device_state_msg() {
  _oneof_case_[0] = kGenericDeviceStateMsg;
}
inline void DeviceStateMessage::clear_generic_device_state_msg() {
  if (has_generic_device_state_msg()) {
    delete msg_.generic_device_state_msg_;
    clear_has_msg();
  }
}
inline  const ::DataTypes::GenericDeviceStateMsg& DeviceStateMessage::generic_device_state_msg() const {
  // @@protoc_insertion_point(field_get:DataTypes.DeviceStateMessage.generic_device_state_msg)
  return has_generic_device_state_msg()
      ? *msg_.generic_device_state_msg_
      : ::DataTypes::GenericDeviceStateMsg::default_instance();
}
inline ::DataTypes::GenericDeviceStateMsg* DeviceStateMessage::mutable_generic_device_state_msg() {
  if (!has_generic_device_state_msg()) {
    clear_msg();
    set_has_generic_device_state_msg();
    msg_.generic_device_state_msg_ = new ::DataTypes::GenericDeviceStateMsg;
  }
  // @@protoc_insertion_point(field_mutable:DataTypes.DeviceStateMessage.generic_device_state_msg)
  return msg_.generic_device_state_msg_;
}
inline ::DataTypes::GenericDeviceStateMsg* DeviceStateMessage::release_generic_device_state_msg() {
  // @@protoc_insertion_point(field_release:DataTypes.DeviceStateMessage.generic_device_state_msg)
  if (has_generic_device_state_msg()) {
    clear_has_msg();
    ::DataTypes::GenericDeviceStateMsg* temp = msg_.generic_device_state_msg_;
    msg_.generic_device_state_msg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void DeviceStateMessage::set_allocated_generic_device_state_msg(::DataTypes::GenericDeviceStateMsg* generic_device_state_msg) {
  clear_msg();
  if (generic_device_state_msg) {
    set_has_generic_device_state_msg();
    msg_.generic_device_state_msg_ = generic_device_state_msg;
  }
  // @@protoc_insertion_point(field_set_allocated:DataTypes.DeviceStateMessage.generic_device_state_msg)
}

// optional .DataTypes.AccessDeviceStateMsg access_device_state_msg = 2;
inline bool DeviceStateMessage::has_access_device_state_msg() const {
  return msg_case() == kAccessDeviceStateMsg;
}
inline void DeviceStateMessage::set_has_access_device_state_msg() {
  _oneof_case_[0] = kAccessDeviceStateMsg;
}
inline void DeviceStateMessage::clear_access_device_state_msg() {
  if (has_access_device_state_msg()) {
    delete msg_.access_device_state_msg_;
    clear_has_msg();
  }
}
inline  const ::DataTypes::AccessDeviceStateMsg& DeviceStateMessage::access_device_state_msg() const {
  // @@protoc_insertion_point(field_get:DataTypes.DeviceStateMessage.access_device_state_msg)
  return has_access_device_state_msg()
      ? *msg_.access_device_state_msg_
      : ::DataTypes::AccessDeviceStateMsg::default_instance();
}
inline ::DataTypes::AccessDeviceStateMsg* DeviceStateMessage::mutable_access_device_state_msg() {
  if (!has_access_device_state_msg()) {
    clear_msg();
    set_has_access_device_state_msg();
    msg_.access_device_state_msg_ = new ::DataTypes::AccessDeviceStateMsg;
  }
  // @@protoc_insertion_point(field_mutable:DataTypes.DeviceStateMessage.access_device_state_msg)
  return msg_.access_device_state_msg_;
}
inline ::DataTypes::AccessDeviceStateMsg* DeviceStateMessage::release_access_device_state_msg() {
  // @@protoc_insertion_point(field_release:DataTypes.DeviceStateMessage.access_device_state_msg)
  if (has_access_device_state_msg()) {
    clear_has_msg();
    ::DataTypes::AccessDeviceStateMsg* temp = msg_.access_device_state_msg_;
    msg_.access_device_state_msg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void DeviceStateMessage::set_allocated_access_device_state_msg(::DataTypes::AccessDeviceStateMsg* access_device_state_msg) {
  clear_msg();
  if (access_device_state_msg) {
    set_has_access_device_state_msg();
    msg_.access_device_state_msg_ = access_device_state_msg;
  }
  // @@protoc_insertion_point(field_set_allocated:DataTypes.DeviceStateMessage.access_device_state_msg)
}

inline bool DeviceStateMessage::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void DeviceStateMessage::clear_has_msg() {
  _oneof_case_[0] = MSG_NOT_SET;
}
inline DeviceStateMessage::MsgCase DeviceStateMessage::msg_case() const {
  return DeviceStateMessage::MsgCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GenericDeviceStateMsg

// optional .DataTypes.Key location_id = 1;
inline bool GenericDeviceStateMsg::has_location_id() const {
  return !_is_default_instance_ && location_id_ != NULL;
}
inline void GenericDeviceStateMsg::clear_location_id() {
  if (GetArenaNoVirtual() == NULL && location_id_ != NULL) delete location_id_;
  location_id_ = NULL;
}
inline const ::DataTypes::Key& GenericDeviceStateMsg::location_id() const {
  // @@protoc_insertion_point(field_get:DataTypes.GenericDeviceStateMsg.location_id)
  return location_id_ != NULL ? *location_id_ : *default_instance_->location_id_;
}
inline ::DataTypes::Key* GenericDeviceStateMsg::mutable_location_id() {
  
  if (location_id_ == NULL) {
    location_id_ = new ::DataTypes::Key;
  }
  // @@protoc_insertion_point(field_mutable:DataTypes.GenericDeviceStateMsg.location_id)
  return location_id_;
}
inline ::DataTypes::Key* GenericDeviceStateMsg::release_location_id() {
  // @@protoc_insertion_point(field_release:DataTypes.GenericDeviceStateMsg.location_id)
  
  ::DataTypes::Key* temp = location_id_;
  location_id_ = NULL;
  return temp;
}
inline void GenericDeviceStateMsg::set_allocated_location_id(::DataTypes::Key* location_id) {
  delete location_id_;
  location_id_ = location_id;
  if (location_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:DataTypes.GenericDeviceStateMsg.location_id)
}

// optional .DataTypes.DeviceType type = 2;
inline void GenericDeviceStateMsg::clear_type() {
  type_ = 0;
}
inline ::DataTypes::DeviceType GenericDeviceStateMsg::type() const {
  // @@protoc_insertion_point(field_get:DataTypes.GenericDeviceStateMsg.type)
  return static_cast< ::DataTypes::DeviceType >(type_);
}
inline void GenericDeviceStateMsg::set_type(::DataTypes::DeviceType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:DataTypes.GenericDeviceStateMsg.type)
}

// optional .DataTypes.DeviceState state = 3;
inline void GenericDeviceStateMsg::clear_state() {
  state_ = 0;
}
inline ::DataTypes::DeviceState GenericDeviceStateMsg::state() const {
  // @@protoc_insertion_point(field_get:DataTypes.GenericDeviceStateMsg.state)
  return static_cast< ::DataTypes::DeviceState >(state_);
}
inline void GenericDeviceStateMsg::set_state(::DataTypes::DeviceState value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:DataTypes.GenericDeviceStateMsg.state)
}

// optional string message = 4;
inline void GenericDeviceStateMsg::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GenericDeviceStateMsg::message() const {
  // @@protoc_insertion_point(field_get:DataTypes.GenericDeviceStateMsg.message)
  return message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GenericDeviceStateMsg::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DataTypes.GenericDeviceStateMsg.message)
}
inline void GenericDeviceStateMsg::set_message(const char* value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DataTypes.GenericDeviceStateMsg.message)
}
inline void GenericDeviceStateMsg::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DataTypes.GenericDeviceStateMsg.message)
}
inline ::std::string* GenericDeviceStateMsg::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:DataTypes.GenericDeviceStateMsg.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GenericDeviceStateMsg::release_message() {
  // @@protoc_insertion_point(field_release:DataTypes.GenericDeviceStateMsg.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GenericDeviceStateMsg::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:DataTypes.GenericDeviceStateMsg.message)
}

// -------------------------------------------------------------------

// AccessDeviceStateMsg

// optional .DataTypes.Key location_id = 1;
inline bool AccessDeviceStateMsg::has_location_id() const {
  return !_is_default_instance_ && location_id_ != NULL;
}
inline void AccessDeviceStateMsg::clear_location_id() {
  if (GetArenaNoVirtual() == NULL && location_id_ != NULL) delete location_id_;
  location_id_ = NULL;
}
inline const ::DataTypes::Key& AccessDeviceStateMsg::location_id() const {
  // @@protoc_insertion_point(field_get:DataTypes.AccessDeviceStateMsg.location_id)
  return location_id_ != NULL ? *location_id_ : *default_instance_->location_id_;
}
inline ::DataTypes::Key* AccessDeviceStateMsg::mutable_location_id() {
  
  if (location_id_ == NULL) {
    location_id_ = new ::DataTypes::Key;
  }
  // @@protoc_insertion_point(field_mutable:DataTypes.AccessDeviceStateMsg.location_id)
  return location_id_;
}
inline ::DataTypes::Key* AccessDeviceStateMsg::release_location_id() {
  // @@protoc_insertion_point(field_release:DataTypes.AccessDeviceStateMsg.location_id)
  
  ::DataTypes::Key* temp = location_id_;
  location_id_ = NULL;
  return temp;
}
inline void AccessDeviceStateMsg::set_allocated_location_id(::DataTypes::Key* location_id) {
  delete location_id_;
  location_id_ = location_id;
  if (location_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:DataTypes.AccessDeviceStateMsg.location_id)
}

// optional bool opened = 2;
inline void AccessDeviceStateMsg::clear_opened() {
  opened_ = false;
}
inline bool AccessDeviceStateMsg::opened() const {
  // @@protoc_insertion_point(field_get:DataTypes.AccessDeviceStateMsg.opened)
  return opened_;
}
inline void AccessDeviceStateMsg::set_opened(bool value) {
  
  opened_ = value;
  // @@protoc_insertion_point(field_set:DataTypes.AccessDeviceStateMsg.opened)
}

// -------------------------------------------------------------------

// CardMsg

// optional string card_num = 1;
inline void CardMsg::clear_card_num() {
  card_num_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CardMsg::card_num() const {
  // @@protoc_insertion_point(field_get:DataTypes.CardMsg.card_num)
  return card_num_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CardMsg::set_card_num(const ::std::string& value) {
  
  card_num_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DataTypes.CardMsg.card_num)
}
inline void CardMsg::set_card_num(const char* value) {
  
  card_num_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DataTypes.CardMsg.card_num)
}
inline void CardMsg::set_card_num(const char* value, size_t size) {
  
  card_num_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DataTypes.CardMsg.card_num)
}
inline ::std::string* CardMsg::mutable_card_num() {
  
  // @@protoc_insertion_point(field_mutable:DataTypes.CardMsg.card_num)
  return card_num_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CardMsg::release_card_num() {
  // @@protoc_insertion_point(field_release:DataTypes.CardMsg.card_num)
  
  return card_num_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CardMsg::set_allocated_card_num(::std::string* card_num) {
  if (card_num != NULL) {
    
  } else {
    
  }
  card_num_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), card_num);
  // @@protoc_insertion_point(field_set_allocated:DataTypes.CardMsg.card_num)
}

// -------------------------------------------------------------------

// CheckMsg

// optional bool ok = 1;
inline void CheckMsg::clear_ok() {
  ok_ = false;
}
inline bool CheckMsg::ok() const {
  // @@protoc_insertion_point(field_get:DataTypes.CheckMsg.ok)
  return ok_;
}
inline void CheckMsg::set_ok(bool value) {
  
  ok_ = value;
  // @@protoc_insertion_point(field_set:DataTypes.CheckMsg.ok)
}

// optional string message = 2;
inline void CheckMsg::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CheckMsg::message() const {
  // @@protoc_insertion_point(field_get:DataTypes.CheckMsg.message)
  return message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CheckMsg::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DataTypes.CheckMsg.message)
}
inline void CheckMsg::set_message(const char* value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DataTypes.CheckMsg.message)
}
inline void CheckMsg::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DataTypes.CheckMsg.message)
}
inline ::std::string* CheckMsg::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:DataTypes.CheckMsg.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CheckMsg::release_message() {
  // @@protoc_insertion_point(field_release:DataTypes.CheckMsg.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CheckMsg::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:DataTypes.CheckMsg.message)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace DataTypes

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::DataTypes::DeviceType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DataTypes::DeviceType>() {
  return ::DataTypes::DeviceType_descriptor();
}
template <> struct is_proto_enum< ::DataTypes::DeviceState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DataTypes::DeviceState>() {
  return ::DataTypes::DeviceState_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_datatypes_2fdevices_2eproto__INCLUDED
