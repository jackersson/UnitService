// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: datatypes/unit.proto

#ifndef PROTOBUF_datatypes_2funit_2eproto__INCLUDED
#define PROTOBUF_datatypes_2funit_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "datatypes/location.pb.h"
#include "datatypes/key.pb.h"
// @@protoc_insertion_point(includes)

namespace DataTypes {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_datatypes_2funit_2eproto();
void protobuf_AssignDesc_datatypes_2funit_2eproto();
void protobuf_ShutdownFile_datatypes_2funit_2eproto();

class ConnectMsg;
class HeartbeatMessage;
class SubscriptionMsg;
class Unit;
class UnitUpdate;
class UnitUpdates;
class Units;

enum UnitState {
  None_ = 0,
  Connected = 1,
  Disconnected = 2,
  UnitState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  UnitState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool UnitState_IsValid(int value);
const UnitState UnitState_MIN = None_;
const UnitState UnitState_MAX = Disconnected;
const int UnitState_ARRAYSIZE = UnitState_MAX + 1;

const ::google::protobuf::EnumDescriptor* UnitState_descriptor();
inline const ::std::string& UnitState_Name(UnitState value) {
  return ::google::protobuf::internal::NameOfEnum(
    UnitState_descriptor(), value);
}
inline bool UnitState_Parse(
    const ::std::string& name, UnitState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UnitState>(
    UnitState_descriptor(), name, value);
}
enum ServiceType {
  None_Service = 0,
  Facial_Service = 1,
  Client_Service = 2,
  Unit_Service = 3,
  ServiceType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ServiceType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ServiceType_IsValid(int value);
const ServiceType ServiceType_MIN = None_Service;
const ServiceType ServiceType_MAX = Unit_Service;
const int ServiceType_ARRAYSIZE = ServiceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServiceType_descriptor();
inline const ::std::string& ServiceType_Name(ServiceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServiceType_descriptor(), value);
}
inline bool ServiceType_Parse(
    const ::std::string& name, ServiceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServiceType>(
    ServiceType_descriptor(), name, value);
}
// ===================================================================

class Unit : public ::google::protobuf::Message {
 public:
  Unit();
  virtual ~Unit();

  Unit(const Unit& from);

  inline Unit& operator=(const Unit& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Unit& default_instance();

  void Swap(Unit* other);

  // implements Message ----------------------------------------------

  inline Unit* New() const { return New(NULL); }

  Unit* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Unit& from);
  void MergeFrom(const Unit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Unit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .DataTypes.Key id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::DataTypes::Key& id() const;
  ::DataTypes::Key* mutable_id();
  ::DataTypes::Key* release_id();
  void set_allocated_id(::DataTypes::Key* id);

  // optional string ip_address = 2;
  void clear_ip_address();
  static const int kIpAddressFieldNumber = 2;
  const ::std::string& ip_address() const;
  void set_ip_address(const ::std::string& value);
  void set_ip_address(const char* value);
  void set_ip_address(const char* value, size_t size);
  ::std::string* mutable_ip_address();
  ::std::string* release_ip_address();
  void set_allocated_ip_address(::std::string* ip_address);

  // repeated .DataTypes.Location locations = 3;
  int locations_size() const;
  void clear_locations();
  static const int kLocationsFieldNumber = 3;
  const ::DataTypes::Location& locations(int index) const;
  ::DataTypes::Location* mutable_locations(int index);
  ::DataTypes::Location* add_locations();
  ::google::protobuf::RepeatedPtrField< ::DataTypes::Location >*
      mutable_locations();
  const ::google::protobuf::RepeatedPtrField< ::DataTypes::Location >&
      locations() const;

  // @@protoc_insertion_point(class_scope:DataTypes.Unit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::DataTypes::Key* id_;
  ::google::protobuf::internal::ArenaStringPtr ip_address_;
  ::google::protobuf::RepeatedPtrField< ::DataTypes::Location > locations_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_datatypes_2funit_2eproto();
  friend void protobuf_AssignDesc_datatypes_2funit_2eproto();
  friend void protobuf_ShutdownFile_datatypes_2funit_2eproto();

  void InitAsDefaultInstance();
  static Unit* default_instance_;
};
// -------------------------------------------------------------------

class ConnectMsg : public ::google::protobuf::Message {
 public:
  ConnectMsg();
  virtual ~ConnectMsg();

  ConnectMsg(const ConnectMsg& from);

  inline ConnectMsg& operator=(const ConnectMsg& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectMsg& default_instance();

  void Swap(ConnectMsg* other);

  // implements Message ----------------------------------------------

  inline ConnectMsg* New() const { return New(NULL); }

  ConnectMsg* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectMsg& from);
  void MergeFrom(const ConnectMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConnectMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .DataTypes.Key id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::DataTypes::Key& id() const;
  ::DataTypes::Key* mutable_id();
  ::DataTypes::Key* release_id();
  void set_allocated_id(::DataTypes::Key* id);

  // optional string ip_address = 2;
  void clear_ip_address();
  static const int kIpAddressFieldNumber = 2;
  const ::std::string& ip_address() const;
  void set_ip_address(const ::std::string& value);
  void set_ip_address(const char* value);
  void set_ip_address(const char* value, size_t size);
  ::std::string* mutable_ip_address();
  ::std::string* release_ip_address();
  void set_allocated_ip_address(::std::string* ip_address);

  // optional .DataTypes.ServiceType service_type = 3;
  void clear_service_type();
  static const int kServiceTypeFieldNumber = 3;
  ::DataTypes::ServiceType service_type() const;
  void set_service_type(::DataTypes::ServiceType value);

  // @@protoc_insertion_point(class_scope:DataTypes.ConnectMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::DataTypes::Key* id_;
  ::google::protobuf::internal::ArenaStringPtr ip_address_;
  int service_type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_datatypes_2funit_2eproto();
  friend void protobuf_AssignDesc_datatypes_2funit_2eproto();
  friend void protobuf_ShutdownFile_datatypes_2funit_2eproto();

  void InitAsDefaultInstance();
  static ConnectMsg* default_instance_;
};
// -------------------------------------------------------------------

class HeartbeatMessage : public ::google::protobuf::Message {
 public:
  HeartbeatMessage();
  virtual ~HeartbeatMessage();

  HeartbeatMessage(const HeartbeatMessage& from);

  inline HeartbeatMessage& operator=(const HeartbeatMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartbeatMessage& default_instance();

  void Swap(HeartbeatMessage* other);

  // implements Message ----------------------------------------------

  inline HeartbeatMessage* New() const { return New(NULL); }

  HeartbeatMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartbeatMessage& from);
  void MergeFrom(const HeartbeatMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HeartbeatMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .DataTypes.Key id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::DataTypes::Key& id() const;
  ::DataTypes::Key* mutable_id();
  ::DataTypes::Key* release_id();
  void set_allocated_id(::DataTypes::Key* id);

  // optional .DataTypes.ServiceType service_type = 2;
  void clear_service_type();
  static const int kServiceTypeFieldNumber = 2;
  ::DataTypes::ServiceType service_type() const;
  void set_service_type(::DataTypes::ServiceType value);

  // @@protoc_insertion_point(class_scope:DataTypes.HeartbeatMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::DataTypes::Key* id_;
  int service_type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_datatypes_2funit_2eproto();
  friend void protobuf_AssignDesc_datatypes_2funit_2eproto();
  friend void protobuf_ShutdownFile_datatypes_2funit_2eproto();

  void InitAsDefaultInstance();
  static HeartbeatMessage* default_instance_;
};
// -------------------------------------------------------------------

class SubscriptionMsg : public ::google::protobuf::Message {
 public:
  SubscriptionMsg();
  virtual ~SubscriptionMsg();

  SubscriptionMsg(const SubscriptionMsg& from);

  inline SubscriptionMsg& operator=(const SubscriptionMsg& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubscriptionMsg& default_instance();

  void Swap(SubscriptionMsg* other);

  // implements Message ----------------------------------------------

  inline SubscriptionMsg* New() const { return New(NULL); }

  SubscriptionMsg* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubscriptionMsg& from);
  void MergeFrom(const SubscriptionMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SubscriptionMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .DataTypes.Key publisher_id = 1;
  bool has_publisher_id() const;
  void clear_publisher_id();
  static const int kPublisherIdFieldNumber = 1;
  const ::DataTypes::Key& publisher_id() const;
  ::DataTypes::Key* mutable_publisher_id();
  ::DataTypes::Key* release_publisher_id();
  void set_allocated_publisher_id(::DataTypes::Key* publisher_id);

  // optional .DataTypes.Key subscriber_id = 2;
  bool has_subscriber_id() const;
  void clear_subscriber_id();
  static const int kSubscriberIdFieldNumber = 2;
  const ::DataTypes::Key& subscriber_id() const;
  ::DataTypes::Key* mutable_subscriber_id();
  ::DataTypes::Key* release_subscriber_id();
  void set_allocated_subscriber_id(::DataTypes::Key* subscriber_id);

  // @@protoc_insertion_point(class_scope:DataTypes.SubscriptionMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::DataTypes::Key* publisher_id_;
  ::DataTypes::Key* subscriber_id_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_datatypes_2funit_2eproto();
  friend void protobuf_AssignDesc_datatypes_2funit_2eproto();
  friend void protobuf_ShutdownFile_datatypes_2funit_2eproto();

  void InitAsDefaultInstance();
  static SubscriptionMsg* default_instance_;
};
// -------------------------------------------------------------------

class Units : public ::google::protobuf::Message {
 public:
  Units();
  virtual ~Units();

  Units(const Units& from);

  inline Units& operator=(const Units& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Units& default_instance();

  void Swap(Units* other);

  // implements Message ----------------------------------------------

  inline Units* New() const { return New(NULL); }

  Units* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Units& from);
  void MergeFrom(const Units& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Units* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .DataTypes.Unit items = 1;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 1;
  const ::DataTypes::Unit& items(int index) const;
  ::DataTypes::Unit* mutable_items(int index);
  ::DataTypes::Unit* add_items();
  ::google::protobuf::RepeatedPtrField< ::DataTypes::Unit >*
      mutable_items();
  const ::google::protobuf::RepeatedPtrField< ::DataTypes::Unit >&
      items() const;

  // @@protoc_insertion_point(class_scope:DataTypes.Units)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::DataTypes::Unit > items_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_datatypes_2funit_2eproto();
  friend void protobuf_AssignDesc_datatypes_2funit_2eproto();
  friend void protobuf_ShutdownFile_datatypes_2funit_2eproto();

  void InitAsDefaultInstance();
  static Units* default_instance_;
};
// -------------------------------------------------------------------

class UnitUpdate : public ::google::protobuf::Message {
 public:
  UnitUpdate();
  virtual ~UnitUpdate();

  UnitUpdate(const UnitUpdate& from);

  inline UnitUpdate& operator=(const UnitUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnitUpdate& default_instance();

  enum UnitTypeCase {
    kInserted = 1,
    kDeleted = 2,
    kUpdated = 3,
    UNIT_TYPE_NOT_SET = 0,
  };

  void Swap(UnitUpdate* other);

  // implements Message ----------------------------------------------

  inline UnitUpdate* New() const { return New(NULL); }

  UnitUpdate* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnitUpdate& from);
  void MergeFrom(const UnitUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UnitUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .DataTypes.Unit inserted = 1;
  bool has_inserted() const;
  void clear_inserted();
  static const int kInsertedFieldNumber = 1;
  const ::DataTypes::Unit& inserted() const;
  ::DataTypes::Unit* mutable_inserted();
  ::DataTypes::Unit* release_inserted();
  void set_allocated_inserted(::DataTypes::Unit* inserted);

  // optional .DataTypes.Unit deleted = 2;
  bool has_deleted() const;
  void clear_deleted();
  static const int kDeletedFieldNumber = 2;
  const ::DataTypes::Unit& deleted() const;
  ::DataTypes::Unit* mutable_deleted();
  ::DataTypes::Unit* release_deleted();
  void set_allocated_deleted(::DataTypes::Unit* deleted);

  // optional .DataTypes.Unit updated = 3;
  bool has_updated() const;
  void clear_updated();
  static const int kUpdatedFieldNumber = 3;
  const ::DataTypes::Unit& updated() const;
  ::DataTypes::Unit* mutable_updated();
  ::DataTypes::Unit* release_updated();
  void set_allocated_updated(::DataTypes::Unit* updated);

  // optional .DataTypes.UnitState state = 4;
  void clear_state();
  static const int kStateFieldNumber = 4;
  ::DataTypes::UnitState state() const;
  void set_state(::DataTypes::UnitState value);

  UnitTypeCase unit_type_case() const;
  // @@protoc_insertion_point(class_scope:DataTypes.UnitUpdate)
 private:
  inline void set_has_inserted();
  inline void set_has_deleted();
  inline void set_has_updated();

  inline bool has_unit_type() const;
  void clear_unit_type();
  inline void clear_has_unit_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int state_;
  union UnitTypeUnion {
    UnitTypeUnion() {}
    ::DataTypes::Unit* inserted_;
    ::DataTypes::Unit* deleted_;
    ::DataTypes::Unit* updated_;
  } unit_type_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_datatypes_2funit_2eproto();
  friend void protobuf_AssignDesc_datatypes_2funit_2eproto();
  friend void protobuf_ShutdownFile_datatypes_2funit_2eproto();

  void InitAsDefaultInstance();
  static UnitUpdate* default_instance_;
};
// -------------------------------------------------------------------

class UnitUpdates : public ::google::protobuf::Message {
 public:
  UnitUpdates();
  virtual ~UnitUpdates();

  UnitUpdates(const UnitUpdates& from);

  inline UnitUpdates& operator=(const UnitUpdates& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnitUpdates& default_instance();

  void Swap(UnitUpdates* other);

  // implements Message ----------------------------------------------

  inline UnitUpdates* New() const { return New(NULL); }

  UnitUpdates* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnitUpdates& from);
  void MergeFrom(const UnitUpdates& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UnitUpdates* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .DataTypes.UnitUpdate items = 1;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 1;
  const ::DataTypes::UnitUpdate& items(int index) const;
  ::DataTypes::UnitUpdate* mutable_items(int index);
  ::DataTypes::UnitUpdate* add_items();
  ::google::protobuf::RepeatedPtrField< ::DataTypes::UnitUpdate >*
      mutable_items();
  const ::google::protobuf::RepeatedPtrField< ::DataTypes::UnitUpdate >&
      items() const;

  // @@protoc_insertion_point(class_scope:DataTypes.UnitUpdates)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::DataTypes::UnitUpdate > items_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_datatypes_2funit_2eproto();
  friend void protobuf_AssignDesc_datatypes_2funit_2eproto();
  friend void protobuf_ShutdownFile_datatypes_2funit_2eproto();

  void InitAsDefaultInstance();
  static UnitUpdates* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Unit

// optional .DataTypes.Key id = 1;
inline bool Unit::has_id() const {
  return !_is_default_instance_ && id_ != NULL;
}
inline void Unit::clear_id() {
  if (GetArenaNoVirtual() == NULL && id_ != NULL) delete id_;
  id_ = NULL;
}
inline const ::DataTypes::Key& Unit::id() const {
  // @@protoc_insertion_point(field_get:DataTypes.Unit.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::DataTypes::Key* Unit::mutable_id() {
  
  if (id_ == NULL) {
    id_ = new ::DataTypes::Key;
  }
  // @@protoc_insertion_point(field_mutable:DataTypes.Unit.id)
  return id_;
}
inline ::DataTypes::Key* Unit::release_id() {
  // @@protoc_insertion_point(field_release:DataTypes.Unit.id)
  
  ::DataTypes::Key* temp = id_;
  id_ = NULL;
  return temp;
}
inline void Unit::set_allocated_id(::DataTypes::Key* id) {
  delete id_;
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:DataTypes.Unit.id)
}

// optional string ip_address = 2;
inline void Unit::clear_ip_address() {
  ip_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Unit::ip_address() const {
  // @@protoc_insertion_point(field_get:DataTypes.Unit.ip_address)
  return ip_address_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Unit::set_ip_address(const ::std::string& value) {
  
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DataTypes.Unit.ip_address)
}
inline void Unit::set_ip_address(const char* value) {
  
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DataTypes.Unit.ip_address)
}
inline void Unit::set_ip_address(const char* value, size_t size) {
  
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DataTypes.Unit.ip_address)
}
inline ::std::string* Unit::mutable_ip_address() {
  
  // @@protoc_insertion_point(field_mutable:DataTypes.Unit.ip_address)
  return ip_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Unit::release_ip_address() {
  // @@protoc_insertion_point(field_release:DataTypes.Unit.ip_address)
  
  return ip_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Unit::set_allocated_ip_address(::std::string* ip_address) {
  if (ip_address != NULL) {
    
  } else {
    
  }
  ip_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip_address);
  // @@protoc_insertion_point(field_set_allocated:DataTypes.Unit.ip_address)
}

// repeated .DataTypes.Location locations = 3;
inline int Unit::locations_size() const {
  return locations_.size();
}
inline void Unit::clear_locations() {
  locations_.Clear();
}
inline const ::DataTypes::Location& Unit::locations(int index) const {
  // @@protoc_insertion_point(field_get:DataTypes.Unit.locations)
  return locations_.Get(index);
}
inline ::DataTypes::Location* Unit::mutable_locations(int index) {
  // @@protoc_insertion_point(field_mutable:DataTypes.Unit.locations)
  return locations_.Mutable(index);
}
inline ::DataTypes::Location* Unit::add_locations() {
  // @@protoc_insertion_point(field_add:DataTypes.Unit.locations)
  return locations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::DataTypes::Location >*
Unit::mutable_locations() {
  // @@protoc_insertion_point(field_mutable_list:DataTypes.Unit.locations)
  return &locations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::DataTypes::Location >&
Unit::locations() const {
  // @@protoc_insertion_point(field_list:DataTypes.Unit.locations)
  return locations_;
}

// -------------------------------------------------------------------

// ConnectMsg

// optional .DataTypes.Key id = 1;
inline bool ConnectMsg::has_id() const {
  return !_is_default_instance_ && id_ != NULL;
}
inline void ConnectMsg::clear_id() {
  if (GetArenaNoVirtual() == NULL && id_ != NULL) delete id_;
  id_ = NULL;
}
inline const ::DataTypes::Key& ConnectMsg::id() const {
  // @@protoc_insertion_point(field_get:DataTypes.ConnectMsg.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::DataTypes::Key* ConnectMsg::mutable_id() {
  
  if (id_ == NULL) {
    id_ = new ::DataTypes::Key;
  }
  // @@protoc_insertion_point(field_mutable:DataTypes.ConnectMsg.id)
  return id_;
}
inline ::DataTypes::Key* ConnectMsg::release_id() {
  // @@protoc_insertion_point(field_release:DataTypes.ConnectMsg.id)
  
  ::DataTypes::Key* temp = id_;
  id_ = NULL;
  return temp;
}
inline void ConnectMsg::set_allocated_id(::DataTypes::Key* id) {
  delete id_;
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:DataTypes.ConnectMsg.id)
}

// optional string ip_address = 2;
inline void ConnectMsg::clear_ip_address() {
  ip_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ConnectMsg::ip_address() const {
  // @@protoc_insertion_point(field_get:DataTypes.ConnectMsg.ip_address)
  return ip_address_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectMsg::set_ip_address(const ::std::string& value) {
  
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DataTypes.ConnectMsg.ip_address)
}
inline void ConnectMsg::set_ip_address(const char* value) {
  
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DataTypes.ConnectMsg.ip_address)
}
inline void ConnectMsg::set_ip_address(const char* value, size_t size) {
  
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DataTypes.ConnectMsg.ip_address)
}
inline ::std::string* ConnectMsg::mutable_ip_address() {
  
  // @@protoc_insertion_point(field_mutable:DataTypes.ConnectMsg.ip_address)
  return ip_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConnectMsg::release_ip_address() {
  // @@protoc_insertion_point(field_release:DataTypes.ConnectMsg.ip_address)
  
  return ip_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectMsg::set_allocated_ip_address(::std::string* ip_address) {
  if (ip_address != NULL) {
    
  } else {
    
  }
  ip_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip_address);
  // @@protoc_insertion_point(field_set_allocated:DataTypes.ConnectMsg.ip_address)
}

// optional .DataTypes.ServiceType service_type = 3;
inline void ConnectMsg::clear_service_type() {
  service_type_ = 0;
}
inline ::DataTypes::ServiceType ConnectMsg::service_type() const {
  // @@protoc_insertion_point(field_get:DataTypes.ConnectMsg.service_type)
  return static_cast< ::DataTypes::ServiceType >(service_type_);
}
inline void ConnectMsg::set_service_type(::DataTypes::ServiceType value) {
  
  service_type_ = value;
  // @@protoc_insertion_point(field_set:DataTypes.ConnectMsg.service_type)
}

// -------------------------------------------------------------------

// HeartbeatMessage

// optional .DataTypes.Key id = 1;
inline bool HeartbeatMessage::has_id() const {
  return !_is_default_instance_ && id_ != NULL;
}
inline void HeartbeatMessage::clear_id() {
  if (GetArenaNoVirtual() == NULL && id_ != NULL) delete id_;
  id_ = NULL;
}
inline const ::DataTypes::Key& HeartbeatMessage::id() const {
  // @@protoc_insertion_point(field_get:DataTypes.HeartbeatMessage.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::DataTypes::Key* HeartbeatMessage::mutable_id() {
  
  if (id_ == NULL) {
    id_ = new ::DataTypes::Key;
  }
  // @@protoc_insertion_point(field_mutable:DataTypes.HeartbeatMessage.id)
  return id_;
}
inline ::DataTypes::Key* HeartbeatMessage::release_id() {
  // @@protoc_insertion_point(field_release:DataTypes.HeartbeatMessage.id)
  
  ::DataTypes::Key* temp = id_;
  id_ = NULL;
  return temp;
}
inline void HeartbeatMessage::set_allocated_id(::DataTypes::Key* id) {
  delete id_;
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:DataTypes.HeartbeatMessage.id)
}

// optional .DataTypes.ServiceType service_type = 2;
inline void HeartbeatMessage::clear_service_type() {
  service_type_ = 0;
}
inline ::DataTypes::ServiceType HeartbeatMessage::service_type() const {
  // @@protoc_insertion_point(field_get:DataTypes.HeartbeatMessage.service_type)
  return static_cast< ::DataTypes::ServiceType >(service_type_);
}
inline void HeartbeatMessage::set_service_type(::DataTypes::ServiceType value) {
  
  service_type_ = value;
  // @@protoc_insertion_point(field_set:DataTypes.HeartbeatMessage.service_type)
}

// -------------------------------------------------------------------

// SubscriptionMsg

// optional .DataTypes.Key publisher_id = 1;
inline bool SubscriptionMsg::has_publisher_id() const {
  return !_is_default_instance_ && publisher_id_ != NULL;
}
inline void SubscriptionMsg::clear_publisher_id() {
  if (GetArenaNoVirtual() == NULL && publisher_id_ != NULL) delete publisher_id_;
  publisher_id_ = NULL;
}
inline const ::DataTypes::Key& SubscriptionMsg::publisher_id() const {
  // @@protoc_insertion_point(field_get:DataTypes.SubscriptionMsg.publisher_id)
  return publisher_id_ != NULL ? *publisher_id_ : *default_instance_->publisher_id_;
}
inline ::DataTypes::Key* SubscriptionMsg::mutable_publisher_id() {
  
  if (publisher_id_ == NULL) {
    publisher_id_ = new ::DataTypes::Key;
  }
  // @@protoc_insertion_point(field_mutable:DataTypes.SubscriptionMsg.publisher_id)
  return publisher_id_;
}
inline ::DataTypes::Key* SubscriptionMsg::release_publisher_id() {
  // @@protoc_insertion_point(field_release:DataTypes.SubscriptionMsg.publisher_id)
  
  ::DataTypes::Key* temp = publisher_id_;
  publisher_id_ = NULL;
  return temp;
}
inline void SubscriptionMsg::set_allocated_publisher_id(::DataTypes::Key* publisher_id) {
  delete publisher_id_;
  publisher_id_ = publisher_id;
  if (publisher_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:DataTypes.SubscriptionMsg.publisher_id)
}

// optional .DataTypes.Key subscriber_id = 2;
inline bool SubscriptionMsg::has_subscriber_id() const {
  return !_is_default_instance_ && subscriber_id_ != NULL;
}
inline void SubscriptionMsg::clear_subscriber_id() {
  if (GetArenaNoVirtual() == NULL && subscriber_id_ != NULL) delete subscriber_id_;
  subscriber_id_ = NULL;
}
inline const ::DataTypes::Key& SubscriptionMsg::subscriber_id() const {
  // @@protoc_insertion_point(field_get:DataTypes.SubscriptionMsg.subscriber_id)
  return subscriber_id_ != NULL ? *subscriber_id_ : *default_instance_->subscriber_id_;
}
inline ::DataTypes::Key* SubscriptionMsg::mutable_subscriber_id() {
  
  if (subscriber_id_ == NULL) {
    subscriber_id_ = new ::DataTypes::Key;
  }
  // @@protoc_insertion_point(field_mutable:DataTypes.SubscriptionMsg.subscriber_id)
  return subscriber_id_;
}
inline ::DataTypes::Key* SubscriptionMsg::release_subscriber_id() {
  // @@protoc_insertion_point(field_release:DataTypes.SubscriptionMsg.subscriber_id)
  
  ::DataTypes::Key* temp = subscriber_id_;
  subscriber_id_ = NULL;
  return temp;
}
inline void SubscriptionMsg::set_allocated_subscriber_id(::DataTypes::Key* subscriber_id) {
  delete subscriber_id_;
  subscriber_id_ = subscriber_id;
  if (subscriber_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:DataTypes.SubscriptionMsg.subscriber_id)
}

// -------------------------------------------------------------------

// Units

// repeated .DataTypes.Unit items = 1;
inline int Units::items_size() const {
  return items_.size();
}
inline void Units::clear_items() {
  items_.Clear();
}
inline const ::DataTypes::Unit& Units::items(int index) const {
  // @@protoc_insertion_point(field_get:DataTypes.Units.items)
  return items_.Get(index);
}
inline ::DataTypes::Unit* Units::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:DataTypes.Units.items)
  return items_.Mutable(index);
}
inline ::DataTypes::Unit* Units::add_items() {
  // @@protoc_insertion_point(field_add:DataTypes.Units.items)
  return items_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::DataTypes::Unit >*
Units::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:DataTypes.Units.items)
  return &items_;
}
inline const ::google::protobuf::RepeatedPtrField< ::DataTypes::Unit >&
Units::items() const {
  // @@protoc_insertion_point(field_list:DataTypes.Units.items)
  return items_;
}

// -------------------------------------------------------------------

// UnitUpdate

// optional .DataTypes.Unit inserted = 1;
inline bool UnitUpdate::has_inserted() const {
  return unit_type_case() == kInserted;
}
inline void UnitUpdate::set_has_inserted() {
  _oneof_case_[0] = kInserted;
}
inline void UnitUpdate::clear_inserted() {
  if (has_inserted()) {
    delete unit_type_.inserted_;
    clear_has_unit_type();
  }
}
inline  const ::DataTypes::Unit& UnitUpdate::inserted() const {
  // @@protoc_insertion_point(field_get:DataTypes.UnitUpdate.inserted)
  return has_inserted()
      ? *unit_type_.inserted_
      : ::DataTypes::Unit::default_instance();
}
inline ::DataTypes::Unit* UnitUpdate::mutable_inserted() {
  if (!has_inserted()) {
    clear_unit_type();
    set_has_inserted();
    unit_type_.inserted_ = new ::DataTypes::Unit;
  }
  // @@protoc_insertion_point(field_mutable:DataTypes.UnitUpdate.inserted)
  return unit_type_.inserted_;
}
inline ::DataTypes::Unit* UnitUpdate::release_inserted() {
  // @@protoc_insertion_point(field_release:DataTypes.UnitUpdate.inserted)
  if (has_inserted()) {
    clear_has_unit_type();
    ::DataTypes::Unit* temp = unit_type_.inserted_;
    unit_type_.inserted_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void UnitUpdate::set_allocated_inserted(::DataTypes::Unit* inserted) {
  clear_unit_type();
  if (inserted) {
    set_has_inserted();
    unit_type_.inserted_ = inserted;
  }
  // @@protoc_insertion_point(field_set_allocated:DataTypes.UnitUpdate.inserted)
}

// optional .DataTypes.Unit deleted = 2;
inline bool UnitUpdate::has_deleted() const {
  return unit_type_case() == kDeleted;
}
inline void UnitUpdate::set_has_deleted() {
  _oneof_case_[0] = kDeleted;
}
inline void UnitUpdate::clear_deleted() {
  if (has_deleted()) {
    delete unit_type_.deleted_;
    clear_has_unit_type();
  }
}
inline  const ::DataTypes::Unit& UnitUpdate::deleted() const {
  // @@protoc_insertion_point(field_get:DataTypes.UnitUpdate.deleted)
  return has_deleted()
      ? *unit_type_.deleted_
      : ::DataTypes::Unit::default_instance();
}
inline ::DataTypes::Unit* UnitUpdate::mutable_deleted() {
  if (!has_deleted()) {
    clear_unit_type();
    set_has_deleted();
    unit_type_.deleted_ = new ::DataTypes::Unit;
  }
  // @@protoc_insertion_point(field_mutable:DataTypes.UnitUpdate.deleted)
  return unit_type_.deleted_;
}
inline ::DataTypes::Unit* UnitUpdate::release_deleted() {
  // @@protoc_insertion_point(field_release:DataTypes.UnitUpdate.deleted)
  if (has_deleted()) {
    clear_has_unit_type();
    ::DataTypes::Unit* temp = unit_type_.deleted_;
    unit_type_.deleted_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void UnitUpdate::set_allocated_deleted(::DataTypes::Unit* deleted) {
  clear_unit_type();
  if (deleted) {
    set_has_deleted();
    unit_type_.deleted_ = deleted;
  }
  // @@protoc_insertion_point(field_set_allocated:DataTypes.UnitUpdate.deleted)
}

// optional .DataTypes.Unit updated = 3;
inline bool UnitUpdate::has_updated() const {
  return unit_type_case() == kUpdated;
}
inline void UnitUpdate::set_has_updated() {
  _oneof_case_[0] = kUpdated;
}
inline void UnitUpdate::clear_updated() {
  if (has_updated()) {
    delete unit_type_.updated_;
    clear_has_unit_type();
  }
}
inline  const ::DataTypes::Unit& UnitUpdate::updated() const {
  // @@protoc_insertion_point(field_get:DataTypes.UnitUpdate.updated)
  return has_updated()
      ? *unit_type_.updated_
      : ::DataTypes::Unit::default_instance();
}
inline ::DataTypes::Unit* UnitUpdate::mutable_updated() {
  if (!has_updated()) {
    clear_unit_type();
    set_has_updated();
    unit_type_.updated_ = new ::DataTypes::Unit;
  }
  // @@protoc_insertion_point(field_mutable:DataTypes.UnitUpdate.updated)
  return unit_type_.updated_;
}
inline ::DataTypes::Unit* UnitUpdate::release_updated() {
  // @@protoc_insertion_point(field_release:DataTypes.UnitUpdate.updated)
  if (has_updated()) {
    clear_has_unit_type();
    ::DataTypes::Unit* temp = unit_type_.updated_;
    unit_type_.updated_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void UnitUpdate::set_allocated_updated(::DataTypes::Unit* updated) {
  clear_unit_type();
  if (updated) {
    set_has_updated();
    unit_type_.updated_ = updated;
  }
  // @@protoc_insertion_point(field_set_allocated:DataTypes.UnitUpdate.updated)
}

// optional .DataTypes.UnitState state = 4;
inline void UnitUpdate::clear_state() {
  state_ = 0;
}
inline ::DataTypes::UnitState UnitUpdate::state() const {
  // @@protoc_insertion_point(field_get:DataTypes.UnitUpdate.state)
  return static_cast< ::DataTypes::UnitState >(state_);
}
inline void UnitUpdate::set_state(::DataTypes::UnitState value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:DataTypes.UnitUpdate.state)
}

inline bool UnitUpdate::has_unit_type() const {
  return unit_type_case() != UNIT_TYPE_NOT_SET;
}
inline void UnitUpdate::clear_has_unit_type() {
  _oneof_case_[0] = UNIT_TYPE_NOT_SET;
}
inline UnitUpdate::UnitTypeCase UnitUpdate::unit_type_case() const {
  return UnitUpdate::UnitTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// UnitUpdates

// repeated .DataTypes.UnitUpdate items = 1;
inline int UnitUpdates::items_size() const {
  return items_.size();
}
inline void UnitUpdates::clear_items() {
  items_.Clear();
}
inline const ::DataTypes::UnitUpdate& UnitUpdates::items(int index) const {
  // @@protoc_insertion_point(field_get:DataTypes.UnitUpdates.items)
  return items_.Get(index);
}
inline ::DataTypes::UnitUpdate* UnitUpdates::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:DataTypes.UnitUpdates.items)
  return items_.Mutable(index);
}
inline ::DataTypes::UnitUpdate* UnitUpdates::add_items() {
  // @@protoc_insertion_point(field_add:DataTypes.UnitUpdates.items)
  return items_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::DataTypes::UnitUpdate >*
UnitUpdates::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:DataTypes.UnitUpdates.items)
  return &items_;
}
inline const ::google::protobuf::RepeatedPtrField< ::DataTypes::UnitUpdate >&
UnitUpdates::items() const {
  // @@protoc_insertion_point(field_list:DataTypes.UnitUpdates.items)
  return items_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace DataTypes

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::DataTypes::UnitState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DataTypes::UnitState>() {
  return ::DataTypes::UnitState_descriptor();
}
template <> struct is_proto_enum< ::DataTypes::ServiceType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DataTypes::ServiceType>() {
  return ::DataTypes::ServiceType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_datatypes_2funit_2eproto__INCLUDED
